初期化

#define RX_BUF_SIZE 300

UART_HandleTypeDef huart2;
DMA_HandleTypeDef hdma_usart2_rx;

uint8_t rx_buf[RX_BUF_SIZE];

void MX_USART2_UART_Init(void)
{
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart2.Init.OverSampling = UART_OVERSAMPLING_16;
    if (HAL_UART_Init(&huart2) != HAL_OK)
    {
        Error_Handler();
    }

    // DMAで受信開始（最大長）
    HAL_UART_Receive_DMA(&huart2, rx_buf, RX_BUF_SIZE);

    // IDLE割り込み有効化
    __HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
}


受信処理
void USART2_IRQHandler(void)
{
    HAL_UART_IRQHandler(&huart2);

    // IDLE割り込みチェック
    if (__HAL_UART_GET_FLAG(&huart2, UART_FLAG_IDLE) != RESET)
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart2);

        // DMAを一旦止める
        HAL_UART_DMAStop(&huart2);

        // 受信済みサイズを計算
        uint16_t received_size = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart2.hdmarx);

        // ここでパケット処理
        process_packet(rx_buf, received_size);

        // DMA再開
        HAL_UART_Receive_DMA(&huart2, rx_buf, RX_BUF_SIZE);
    }
}

パケット処理例
void process_packet(uint8_t *buf, uint16_t len)
{
    if (len < 2) return; // サイズ情報すらない場合

    uint8_t packet_size = buf[1];  // 2バイト目にサイズが入っている

    if (packet_size <= len)
    {
        // packet_size バイト分が有効データ
        // ここでアプリ側に渡す
    }
    else
    {
        // サイズ不一致 → エラーハンドリング
    }
}

受信開始
// DMA受信開始（最大サイズ）
HAL_UART_Receive_DMA(&huart2, rx_buf, RX_BUF_SIZE);

// IDLE割り込み有効化
__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);

CubeMX が生成する stm32f4xx_it.c 内の USART2 IRQ Handler:
void USART2_IRQHandler(void)
{
    HAL_UART_IRQHandler(&huart2);

    if (__HAL_UART_GET_FLAG(&huart2, UART_FLAG_IDLE) != RESET)
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart2);

        // DMA停止して受信サイズ取得
        HAL_UART_DMAStop(&huart2);
        uint16_t received_size = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart2.hdmarx);

        process_packet(rx_buf, received_size);

        // DMA再開
        HAL_UART_Receive_DMA(&huart2, rx_buf, RX_BUF_SIZE);
    }
}








import ctypes

class MyDLL:
    """
    DLLラッパークラス（テンプレート）
    - 出力バッファ型関数は Python の str に変換
    - 数値型関数はそのまま返す
    - 関数定義を一括管理するので、関数が増えても簡単に追加可能
    """
    def __init__(self, path: str):
        self.dll = ctypes.CDLL(path)

        # 関数定義リスト： ("関数名", [引数型], 戻り値型, "buffer" or "number")
        self.functions = [
            ("GetStatus", [ctypes.c_char_p, ctypes.c_int], ctypes.c_int, "buffer"),
            ("MakeMessage", [ctypes.c_char_p, ctypes.c_int], ctypes.c_int, "buffer"),
            ("CalcSum", [ctypes.c_int, ctypes.c_int], ctypes.c_int, "number"),
            # ↓ ここに残り27個くらいの関数を同じ形式で追加
            # ("関数名", [argtypes], restype, "buffer" or "number"),
        ]

        # DLL関数の型を自動設定
        self._setup_functions()

    def _setup_functions(self):
        for name, argtypes, restype, _ in self.functions:
            func = getattr(self.dll, name)
            func.argtypes = argtypes
            func.restype = restype

    # ラッパーメソッド自動生成用ヘルパー
    def _call_buffer_func(self, name: str, bufsize: int = 256):
        buf = ctypes.create_string_buffer(bufsize)
        func = getattr(self.dll, name)
        ret = func(buf, bufsize)
        return buf.value.decode("ascii"), ret

    def _call_number_func(self, name: str, *args):
        func = getattr(self.dll, name)
        return func(*args)

    # 個別ラッパー（Python側で呼びやすくする）
    def get_status(self, bufsize: int = 256):
        return self._call_buffer_func("GetStatus", bufsize)

    def make_message(self, bufsize: int = 256):
        return self._call_buffer_func("MakeMessage", bufsize)

    def calc_sum(self, a: int, b: int):
        return self._call_number_func("CalcSum", a, b)






from mydll_wrapper import MyDLL

if __name__ == "__main__":
    mydll = MyDLL(r"C:\path\to\your.dll")

    msg, ret = mydll.get_status()
    print("GetStatus:", msg, "(戻り値:", ret, ")")

    msg, ret = mydll.make_message()
    print("MakeMessage:", msg, "(戻り値:", ret, ")")

    result = mydll.calc_sum(10, 32)
    print("CalcSum:", result)


